<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Implementation of STL</title>
	<!-- <link rel="stylesheet" type="text/css" href="README.css"> -->
</head>
<body>
	<h1>DOCUMENTATION OF A PROJECT</h1>
	<h2>(Implementation of some functions and containers with corresponding iterators of STANDARD TEMPLATE LIBRARY)</h2>

	<h3>1)Understanding STL first :</h3>

	<p>The C++ STL (Standard Template Library) is a powerful set of C++ template classes to provide general-purpose classes and functions with templates that implement many popular and commonly used <em>algorithms</em> and <em>data structures</em> like <strong>vectors</strong>, <strong>lists</strong>, <strong>queues</strong>, and <strong>stacks</strong>.</p>

	<p>There are some great resources available for STL on the internet,Some of them are:
	<ul>
		<li><a href="https://www.geeksforgeeks.org/the-c-standard-template-library-stl/">STL - GeeksForGeeks</a></li>
		<li><a href="https://www.hackerearth.com/practice/notes/standard-template-library/">STL - HackerEarth</a></li>
	</ul>
	</p>

	<h3>2)About the Project :</h3>

	<p>In this Project we have tried to implement some basic algorithmic functions and some useful data structures from <strong>STANDARD TEMPLATE LIBRARY</strong>.STL is mainly divided into three parts :
		<ul>
			<li><strong>Algorithms</strong></li>
			<li><strong>Containers</strong></li>
			<li><strong>Iterators</strong></li>
		</ul>
	</p>

	<p>So here we have created one <strong><em>"Algorithm.h"</em></strong> file in which some algorithmic functions are defined.After that for the containers we have created a separate file for each container such as for vector <strong><em>"Vector.h"</em></strong>,for set <strong><em>"Set.h"</em></strong>,etc.Now for iterators,if you have gone through the STL tutorials you have noticed that there are several types of iterators are used according to the need of the container.It is a standard practice that the several types of iterator files should be created first and then those should be used according to the requirement but instead of doing this we have created iterator as a component of a container in the container file itself and used it there,But stil it works like a standard iterator file only.</p>

	<h3>3)Let's have a look :</h3>

	<p>Now we will go through each and every function and container.</p>

	<h4>Algorithm File :</h4>

	<p>*Kindly notice that the name of the file is <strong><em>"Algorithm.h"</em></strong>.</p>

	<ul>
		<li><strong>sort(first_iterator,last_iterator) :</strong>It sorts the given array or vector in ascending order.</li>
		<br>
		<li><strong>binary_search(first_element,last_element,search element) :</strong>This function will return true if the element will be in the given range or else it will return false.The precondition required here is that the elements in the given range should be sorted in ascending order.</li>
		<br>
		<li><strong>reverse(first_iterator,last_iterator) :</strong>This function reverses the given array or vector.</li>
		<br>
		<li><strong>max_element(first_iterator,last_iterator) :</strong>This function returns the iterator(pointer) to the maximum element in the given range.</li>
		<br>
		<li><strong>min_element(first_iterator,last_iterator) :</strong>This function returns the iterator(pointer) to the minimum element in the given range.</li>
		<br>
		<li><strong>accumulate(first_iterator,last_iterator,sum) :</strong>This function does the summation of all elements of an array or a vector and adds it to the sum parameter and return it.</li>
		<br>
		<li><strong>count(first_iterator,last_iterator,element) :</strong>This function counts the occurences of provided element and returns it.</li>
		<br>
		<li><strong>find(first_iterator,last_iterator,element) :</strong>This function searches the provided element in the given array or vector linearly and returns the pointer to the given element.If the element will not be in the range,it returns the last address of an array or the vector.</li>
		<br>
		<li><strong>distance(first_iterator,desired_position) :</strong>It returns the distance of desired position from the first iterator.This function is very useful while finding the index.</li>
		<br>
		<li><strong>next_permutation(first_iterator,last_iterator) :</strong>This modified the vector to its next permutation.</li>
	</ul>

	<h4>Vector File :</h4>

	<p>*Remember the file name is <em><strong>"Vector.h".</strong></em></p>

	<ul>
		<li><strong>begin()</strong> : Returns an iterator pointing to the first element in the vector</li>
		<br>
		<li><strong>end()</strong> : Returns an iterator pointing to the theoretical element that follows the last element in the vector</li>
		<br>
		<li><strong>size()</strong> : Returns the number of elements in the vector.</li>
		<br>
	    <li><strong>capacity()</strong> : Returns the size of the storage space currently allocated to the vector expressed as number of elements.</li>
	    <br>
	    <li><strong>push_back(element)</strong> : It push the elements into a vector from the back.</li>
	    <br>
	    <li><strong>pop_back()</strong> : It is used to pop or remove elements from a vector from the back.</li>
	    <br>
	    <li><strong>empty()</strong> : Returns whether the container is empty.</li>
	    <br>
	    <li><strong>front()</strong> : Returns a reference to the first element in the vector.</li>
	    <br>
	    <li><strong>back()</strong> : Returns a reference to the last element in the vector</li>
	    <br>
	    <li><strong>clear()</strong> : It is used to remove all the elements of the vector container.</li>
	    <br>
	    <li><strong>erase(position)</strong> : It is used to remove elements from a container from the specified position.</li>
	    <br>
	</ul>

	<h4>Stack File :</h4>

	<p>*Remember the file name is <em><strong>"Stack.h".</strong></em></p>

	<ul>
    <li><strong>empty()</strong> : Returns whether the stack is empty.</li>
    <br>
    <li><strong>size()</strong> : Returns the size of the stack.</li>
    <br>
    <li><strong>push(g)</strong> : Adds the element ‘g’ at the top of the stack.</li>
    <br>
    <li><strong>top()</strong> : Returns a reference to the top most element of the stack.</li>
    <br>
    <li><strong>pop()</strong> : Deletes the top most element of the stack.</li>
    <br>
	</ul>

	<h4>Queue File :</h4>
	 <p>*Remember the file name is <em><strong>"Queue.h".</strong></em></p>

	 <ul>
	 	<li><strong>push(g)</strong> : This function adds the element ‘g’ at the end of the queue.</li>
	 	<br>
	    <li><strong>pop()</strong> : This function deletes the first element of the queue.</li>
	    <br>
	    <li><strong>front()</strong> : This function returns a reference to the first element of the queue.</li>
	    <br>
	    <li><strong>back()</strong> : This function returns a reference to the last element of the queue.</li>
	    <br>
	    <li><strong>size()</strong> : Returns the size of the queue.</li>
	    <br>
    	<li><strong>empty()</strong> : Returns whether the queue is empty.</li>
    	<br>
	 </ul>

	 <h4>List File :</h4>
	 <p>*Rememberthe file name is <em><strong>"List.h".</strong></em></p>

	 <ul>
	 	<li><strong>front()</strong> : Returns the value of the first element in the list.</li>
	 	<br>
	    <li><strong>back()</strong> : Returns the value of the last element in the list.</li>
	    <br>
	    <li><strong>push_front(g)</strong> : Adds a new element ‘g’ at the beginning of the list.</li>
	    <br>
	    <li><strong>push_back(g)</strong> : Adds a new element ‘g’ at the end of the list.</li>
	    <br>
	    <li><strong>begin()</strong> : This function returns an iterator pointing to the first element of the list.</li>
	    <br>
	    <li><strong>end()</strong> : This function returns an iterator pointing to the theoretical last element which follows the last element.</li>
	    <br>
	    <li><strong>display()</strong> : This function displays all the elements in the list.</li>
	    <br>
	    <li><strong>delAll()</strong> : This function deletes all the elements in the list.</li>
	    <br>
	    <li><strong>pop_front()</strong> : Removes the first element of the list, and reduces size of the list by 1.</li>
	    <br>
	    <li><strong>pop_back()</strong> : Removes the last element of the list, and reduces size of the list by 1.</li>
	    <br>
	    <li><strong>empty()</strong> : Returns whether the list is empty(1) or not(0).</li>
	    <br>
	    <li><strong>insert(position,g)</strong> : This function inserts the element 'g' at the specified position.</li>
	    <br>
	    <li><strong>erase(position)</strong> : This function erases the element at a specified position.</li>
	    <br>
	    <li><strong>assign(count,g)</strong> : This function assigns the element 'g' 'count' number of times to the list.</li>
	    <br>
	    <li><strong>assign(second_list.begin(),second_list.end())</strong> : This function copies the elements from an existing list to the second list.</li>
	    <br>
	    <li><strong>remove(g)</strong> : This function deletes all the elements with value 'g' from the list.</li>
	    <br>
	    <li><strong>reverse()</strong> : This function reverses the list.</li>
	    <br>
	   <li><strong>size()</strong> : Returns the number of elements in the list.</li>
	   	<br>
	    <li><strong>Sort()</strong> : This function sorts the list in an increasing order.</li>
	    <br>
	    <li><strong>clear()</strong> : This function is same as the delAll() function which deletes all the elements in the list.</li>
	    <br>
	 </ul>

	 <h4>Pair File :</h4>

	 <p>*Rememberthe file name is <em><strong>"Pair.h".</strong></em></p>
	 <p>The pair container is a simple container consisting of two data elements or objects.</p>

	 <ul>
	 	<li>The first element is referenced as ‘first’ and the second element as ‘second’ and the order is fixed (first, second).</li>
	 	<br>
	 	<li>Pair is used to combine together two values which may be different in type. Pair provides a way to store two heterogeneous objects as a single unit.</li>
	 	<br>
		<li>Pair can be assigned, copied and compared. The array of objects allocated in a map or hash_map are of type ‘pair’ by default in which all the ‘first’ elements are unique keys associated with their ‘second’ value objects.</li>
		<br>
		<li>To access the elements, we use variable name followed by dot operator followed by the keyword first or second.</li>
		<br>
	 </ul>

	 <ul>
	 	<li><strong>Make_pair()</strong> : This template function allows to create a value pair without writing the types explicitly.</li>
	 	<br>
	 	<li><strong>Operators(=,==,!=,>=,<=)</strong> : These operators can be directly used with pairs.</li>
	 	<br>
	 	<li><strong>Swap()</strong> : This function swaps the contents of one pair object with the contents of another pair object. The pairs must be of same type.</li> 
	 	<br>
	 </ul>
	 
	 <h4>Set File :</h4>

	 <p>*Remember the file name is <em><strong>"Set.h".</strong></em></p>
	 
	 <ul>
		<li><strong>insert(g)</strong> : This function inserts the element 'g' in the ordered set.</li>
		<br>
	    <li><strong>size()</strong> : This function returns the size(number of elements) of the set.</li>
	    <br>
	   	<li><strong>empty()</strong> : This function returns true if set container is empty else returns false.</li>
	   	<br>
	    <li><strong>search(g)</strong> : This function searches the value 'g' in the set container and returns true if found else returns falase.</li>
	    <br>
	    <li><strong>getroot()</strong> : This function returns the root of the BST(Binary search tree) in which elements are stored.</li>
	    <br>
	    <li><strong>begin()</strong> : This function returns the beginning iterator of the set.</li>
	    <br>
	    <li><strong>end()</strong> : This function returns the ending iterator of the set.</li>
	    <br>
	    <li><strong>display(Iterator_root)</strong> : This function displays the elements in the set container in INORDER manner.</li> 
	    <br>
	 </ul>
	 
</body>
</html>